#!/usr/bin/env python
# coding: utf-8

# 5G NR matrix ::: BG-1
# Lifting size Z = 8
# Using alist generated by alist_generate.m

import numpy as np
import fgSiva
import pathlib
import os
import matplotlib.pyplot as plt

# Get the current path of the file

current_dir = pathlib.Path(__file__).parent

Z = 8       # Lifting size
N = 68 * Z  # Variable nodes
m = 46 * Z  # Check nodes

start_lines = 4                    # Initial redundant information in alist
check2var_lines = start_lines + m  # Scoop check2var lines in a list

# Read the alist


class NR_1_0_8(fgSiva.Encoding):
        def __init__(self, seclength=1):
            
            with open(os.path.join(current_dir,'NR_1_0_8_alist.alist'),'r') as file:
                lines = file.read().splitlines()


            lines=lines[start_lines:check2var_lines] # skip the first 4 lines in the alist

            self.Check2VarEdges=[]

            for i in range(m):

                line = lines[i]
                line_entry = lines[i].split()
                line_len = len(line.split())
                val = []

                for j in range(line_len):
                    
                    temp_val = int(line_entry[j])
                    
                    if temp_val != 0:
                        val.append(int(line_entry[j])) 
                
                self.Check2VarEdges.append(val)
            
            super().__init__(self.Check2VarEdges, None, seclength)

# Open the file to write values

file=open(r'C:\Users\SIVA ADITYA GOOTY\Desktop\Git\LDPC_decoder\values.txt','w')

# Define SNR points

EbNo_dB = np.arange(0,2.5,0.5)
EbNo = np.zeros(len(EbNo_dB))

# Store error values per point 

err_values = np.zeros(len(EbNo_dB))

# Number of error acuumulations

err_acc = 50

for point in range(len(EbNo_dB)):
    
    # Define parameters for Monte Carlo simulatons
    
    err_fixed = 0

    n_err = 0

    n_iter = 0

    while n_err < err_acc:

        # Variance calculation :

        EbNo[point] = 10**(EbNo_dB[point]/10)
        rate = ((N-m)/(N-2*Z))
        nvar = 1/(2*rate*EbNo[point])


        # Initialize LDPC factor graph

        LDPCFactorGraph = NR_1_0_8()

        # Pull the parity matrix and store for future  parity checks

        H = LDPCFactorGraph.paritycheckmatrix

        # All zero msg

        msg = np.zeros(N-m)

        # Encode codeword

        c = LDPCFactorGraph.encodemessage(msg)

        # We can verify that c is now of the proper length

        assert len(c) == N

        # As m is the all zero message, its codeword should also be the all zero codeword. We can verify that as well: 

        # print(c)


        # Add AWGN

        x = (2*c-1)                                      # modulate using binary phase shift keying (BPSK) ::: a = - 1
        n = np.sqrt(nvar) * np.random.randn(len(c))      # generate random Gaussian noise
        y = x + n                                        # generate noisy observation of c


        # Run the encoding and decoding


        # Note: it is good practice to reset the factor graph if you will be using it multiple times in a row
        # (e.g. averaging over multiple simulations)

        LDPCFactorGraph.reset()

        # Initialize variable nodes with observations
        # Note that varnodeid is starts with 1 and python utilizes 0-based indexing

        # LDPCFactorGraph.printgraphcontent()

        for varnodeid in LDPCFactorGraph.varlist:

            LLR = (-2/nvar)* y[varnodeid-1]

            # 5G-NR method to set first two col's in parity check matrix as 0 => LLR = 0
             
            if varnodeid <= 2*Z:

                LDPCFactorGraph.setobservation(varnodeid, 0)

            else:

                LDPCFactorGraph.setobservation(varnodeid, LLR)

        # LDPCFactorGraph.printgraphcontent()
        
        # Run message-passing algorithm on graph for following max iterations

        numIterations = 50

        for idxiteration in range(numIterations):

            LDPCFactorGraph.updatechecks()
            LDPCFactorGraph.updatevars()

            # Temporary codeword

            tmp = np.zeros(N)

            for varnodeid in LDPCFactorGraph.varlist:

                tmp[varnodeid - 1] = LDPCFactorGraph.getextrinsicestimate(varnodeid) + LDPCFactorGraph.getobservation(varnodeid)

                # Thresholding for BPSK

                if tmp[varnodeid - 1] < 0:

                    tmp[varnodeid - 1] = 1

                else:

                    tmp[varnodeid - 1] = 0

            # Check if the current codeword satifies parity constraint

            Parity_check = np.matmul(H,tmp.T)

            if np.all(Parity_check == 0):
                break
            # print("######",idxiteration)
            # LDPCFactorGraph.printgraphcontent()

        # Extract information from graph

        # tmp = np.zeros(N)

        # for varnodeid in LDPCFactorGraph.varlist:
        #
        #     tmp[varnodeid-1] = LDPCFactorGraph.getextrinsicestimate(varnodeid)+LDPCFactorGraph.getobservation(varnodeid)
        #
        #     # Thresholding for BPSK
        #
        #     if tmp[varnodeid-1]<0:
        #
        #         tmp[varnodeid-1]=1
        #
        #     else:
        #
        #         tmp[varnodeid-1]=0

        # Accumulate the errors

        if np.sum(c != tmp) != 0:
            
            n_err += 1
            err_fixed += np.sum(c != tmp)

        # Accumulate iterations required for err_req

        n_iter+= 1
    
    # Store error values per SNR point

    err_values[point] = err_fixed/(n_iter*N)

    print(n_iter,err_values[point],EbNo_dB[point])

    file.write(str(err_values[point])+"\n")
    
file.close()

# BER VS EbNo_dB plot


plt.semilogy(EbNo_dB,err_values,'-*r')
plt.grid(True,which="both",ls="-")
plt.xlabel('EbNo_dB')
plt.ylabel('Codeword error rate')
plt.title('Monte-Carlo simulations')

plt.show()



# plt.savefig(os.path.join(current_dir, "BER vs Eb_NodB.png"))

